// This file was automatically generated by the pas2jni utility.
// Do not edit this file.
library personmodeljni;
{$ifdef fpc} {$mode objfpc} {$H+} {$endif}

uses
  {$ifdef unix} cthreads, {$endif}
  PersonModel,
  {$ifndef FPC} Windows, {$endif} SysUtils, SyncObjs, jni;

type
  _JNIString = {$ifdef FPC} unicodestring {$else} widestring {$endif};
  {$ifndef FPC} ptruint = cardinal; {$endif}

  _TJavaClassInfo = record
    ClassRef: JClass;
    ConstrId: JMethodId;
    ObjFieldId: JFieldId;
  end;
  _PJavaClassInfo = ^_TJavaClassInfo;

var _Java_String_Info: _TJavaClassInfo;

function _StringFromJString(env: PJNIEnv; s: jstring): _JNIString;
var
  p: PJChar;
  c: JBoolean;
begin
  if s = nil then begin
    Result:='';
    exit;
  end;
  p:=env^^.GetStringChars(env, s, c);
  SetString(Result, PWideChar(p), env^^.GetStringLength(env, s));
  env^^.ReleaseStringChars(env, s, p);
end;

function _StringToJString(env: PJNIEnv; const s: _JNIString): jstring;
begin
  Result:=env^^.NewString(env, PJChar(PWideChar(s)), Length(s));
end;

function _CreateJavaObj(env: PJNIEnv; PasObj: jlong; const ci: _TJavaClassInfo; cleanup: boolean = True): jobject; overload;
var v: array [0..1] of jvalue;
begin
  Result:=nil;
  if PasObj = 0 then exit;
  v[0].J:=PasObj;
  if ci.ConstrId = nil then begin
    Result:=env^^.AllocObject(env, ci.ClassRef);
    if Result = nil then exit;
    env^^.SetLongField(env, Result, ci.ObjFieldId, v[0].J);
  end else begin
    v[1].Z:=byte(cleanup) and 1;
    Result:=env^^.NewObjectA(env, ci.ClassRef, ci.ConstrId, @v);
  end;
end;

function _CreateJavaObj(env: PJNIEnv; PasObj: pointer; const ci: _TJavaClassInfo; cleanup: boolean = True): jobject; overload;
begin
  Result:=_CreateJavaObj(env, jlong(ptruint(PasObj)), ci, cleanup)
end;


function _GetPasObj(env: PJNIEnv; jobj: jobject; const ci: _TJavaClassInfo; CheckNil: boolean): pointer;
var pasobj: jlong;
begin
  if jobj <> nil then
    pasobj:=env^^.GetLongField(env, jobj, ci.ObjFieldId)
  else
    pasobj:=0;
  if CheckNil and (pasobj <= 0) then
    raise Exception.Create('Attempt to access a released Pascal object.');
  Result:=pointer(ptruint(pasobj));
end;

function _GetClass(env: PJNIEnv; jobj: jobject; const ci: _TJavaClassInfo): TClass;
var pasobj: jlong;
begin
  if jobj <> nil then
    pasobj:=env^^.GetLongField(env, jobj, ci.ObjFieldId)
  else
    pasobj:=0;
  if pasobj > 0 then
    Result:=TObject(ptruint(pasobj)).ClassType
  else
    Result:=TClass(ptruint(-pasobj));
end;

procedure _HandleJNIException(env: PJNIEnv);
begin
  env^^.ThrowNew(env, env^^.FindClass(env, 'java/lang/Exception'), PAnsiChar(Utf8Encode(Exception(ExceptObject).Message)));
end;

procedure _RaiseVarParamException(const VarName: string);
begin
  raise Exception.CreateFmt('An array with only single element must be passed as parameter "%s".', [VarName]);
end;

function _AllocMemory(env: PJNIEnv; jobj: jobject; size: jint): jlong;{$ifdef mswindows} stdcall {$else} cdecl {$endif};
var p: pointer;
begin
  GetMem(p, size);
  FillChar(p^, size, 0);
  Result:=ptruint(p);
end;

function _GetIntObjValue(env: PJNIEnv; jobj: jobject; const ci: _TJavaClassInfo): longint;
begin
  if jobj = nil then raise Exception.Create('Attempt to access a NULL set.');
  Result:=env^^.GetIntField(env, jobj, ci.ObjFieldId);
end;

function _CreateIntObj(env: PJNIEnv; Value: longint; const ci: _TJavaClassInfo): jobject;
begin
  Result:=nil;
  Result:=env^^.AllocObject(env, ci.ClassRef);
  if Result = nil then exit;
  env^^.SetIntField(env, Result, ci.ObjFieldId, Value);
end;

{ Unit System }

var _JNI_personmodeljni__TMethodPtrInfo_Info: _TJavaClassInfo;

type
  _TMethodPtrInfo = class
    Obj: JObject;
    MethodId: JMethodID;
    Index, RefCnt: integer;
    RealMethod: TMethod;
    InlineHandler: boolean;
    constructor Create(env: PJNIEnv; JavaObj: JObject; const AMethodName, AMethodSig: ansistring);
    procedure Release(env: PJNIEnv);
  end;

var _MethodPointers: array of _TMethodPtrInfo;
var _MethodPointersCS: TCriticalSection;

constructor _TMethodPtrInfo.Create(env: PJNIEnv; JavaObj: JObject; const AMethodName, AMethodSig: ansistring);
var c: JClass;
begin
  if (JavaObj = nil) or (AMethodName = '') then exit;
  c:=env^^.GetObjectClass(env, JavaObj);
  if c = nil then exit;
  MethodId:=env^^.GetMethodID(env, c, PAnsiChar(AMethodName), PAnsiChar(AMethodSig));
  if MethodId = nil then raise Exception.CreateFmt('Method "%s" does not exist or has wrong parameters.', [AMethodName]);
  Obj:=env^^.NewGlobalRef(env, JavaObj);
  _MethodPointersCS.Enter;
  try
    Index:=Length(_MethodPointers) + 1;
    if Index > 10000 then raise Exception.Create('Too many method pointers.');
    SetLength(_MethodPointers, Index);
    _MethodPointers[Index - 1]:=Self;
  finally
    _MethodPointersCS.Leave;
  end;
end;

procedure _TMethodPtrInfo.Release(env: PJNIEnv);
var i: integer;
begin
  i:=InterlockedDecrement(RefCnt);
  if i <> 0 then exit;
  if Index > 0 then begin
    _MethodPointersCS.Enter;
    try
      if InlineHandler then begin
        env^^.SetLongField(env, Obj, _JNI_personmodeljni__TMethodPtrInfo_Info.ObjFieldId, -1);
      end;
      env^^.DeleteGlobalRef(env, Obj);
      _MethodPointers[Index-1]:=nil;
      Index:=High(_MethodPointers);
      while (Index >= 0) and (_MethodPointers[Index] = nil) do Dec(Index);
      SetLength(_MethodPointers, Index + 1);
    finally
      _MethodPointersCS.Leave;
    end;
  end;
  Self.Destroy;
end;

procedure _RefMethodPtr(env: PJNIEnv; const m: TMethod; AddRef: boolean);
var i: integer;
begin
  i:=-integer(ptruint(m.Data));
  if (i < 1) or (i > 10000) then exit;
  _MethodPointersCS.Enter;
  try
    with _MethodPointers[i - 1] do
      if AddRef then InterlockedIncrement(RefCnt) else Release(env);
  finally
    _MethodPointersCS.Leave;
  end;
end;

function _CreateMethodPtrObject(env: PJNIEnv; const m: TMethod; const ci: _TJavaClassInfo): jobject;
var i: integer;
var mpi: _TMethodPtrInfo;
begin
  _MethodPointersCS.Enter;
  try
    i:=-integer(ptruint(m.Data));
    if (i > 0) and (i <= 10000) then begin
      mpi:=_MethodPointers[i - 1];
    end
    else begin
      mpi:=_TMethodPtrInfo.Create(env, nil, '', '');
      mpi.RealMethod:=m;
    end;
    InterlockedIncrement(mpi.RefCnt);
  finally
    _MethodPointersCS.Leave;
  end;
  Result:=_CreateJavaObj(env, pointer(mpi), ci);
end;

function _GetMethodPtrHandler(env: PJNIEnv; jobj: jobject; hptr: pointer; const ci: _TJavaClassInfo): TMethod;
var mpi: _TMethodPtrInfo;
begin
  Result.Data:=nil; Result.Code:=nil;
  mpi:=_TMethodPtrInfo(_GetPasObj(env, jobj, ci, False));
  if mpi = nil then exit;
  if pointer(mpi) = pointer(ptruint(-1)) then begin
    env^^.CallVoidMethodA(env, jobj, env^^.GetMethodID(env, ci.ClassRef, 'Init', '()V'), nil);
    Result:=_GetMethodPtrHandler(env, jobj, hptr, ci);
    exit;
  end;
  if mpi.Index = 0 then
    TMethod(Result):=mpi.RealMethod
  else
    with TMethod(Result) do begin
      Data:=pointer(ptruint(-integer(mpi.Index)));
      Code:=hptr;
    end;
end;

procedure _TMethodPtrInfo_Init(env: PJNIEnv; _self, JavaObj: JObject; AMethodName, AMethodSig: jstring; IncRef: jboolean);{$ifdef mswindows} stdcall {$else} cdecl {$endif};
var mpi: _TMethodPtrInfo;
begin
  try
    mpi:=_TMethodPtrInfo.Create(env, JavaObj, ansistring(_StringFromJString(env, AMethodName)), ansistring(_StringFromJString(env, AMethodSig)));
    if IncRef <> 0 then
      InterlockedIncrement(mpi.RefCnt)
    else
      mpi.InlineHandler:=True;
    env^^.SetLongField(env, _self, _JNI_personmodeljni__TMethodPtrInfo_Info.ObjFieldId, Int64(ptruint(mpi)));
  except
    _HandleJNIException(env);
  end;
end;

procedure _TMethodPtrInfo_Release(env: PJNIEnv; _self: JObject);{$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  try
    _TMethodPtrInfo(_GetPasObj(env, _self, _JNI_personmodeljni__TMethodPtrInfo_Info, True)).Release(env);
  except
    _HandleJNIException(env);
  end;
end;

function _IntfCast(env: PJNIEnv; _self: JObject; objptr: jlong; objid: jstring): jlong;{$ifdef mswindows} stdcall {$else} cdecl {$endif};
var
  obj: system.TObject;
  intf: IUnknown;
begin
  Result:=0;
  try
    if objptr = 0 then exit;
    if objid = nil then
      raise Exception.Create('A GUID must be assigned for the interface to allow a type cast.');
    obj:=system.TObject(pointer(ptruint(objptr)));
    if not (obj is system.TInterfacedObject) then
      raise Exception.Create('Object must be inherited from TInterfacedObject.');
    if (system.TInterfacedObject(obj) as IUnknown).QueryInterface(StringToGUID(ansistring(_StringFromJString(env, objid))), intf) <> 0 then
      raise Exception.Create('Invalid type cast.');
    intf._AddRef;
    Result:=ptruint(intf);
  except
    _HandleJNIException(env);
  end;
end;

var _JNI_system_TObject_Info: _TJavaClassInfo;

var _JNI_system_TClass_Info: _TJavaClassInfo;

{ TObject }

function JNI_system_TObject_Create(_env: PJNIEnv; _jobj: jobject): jobject; {$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  try
    Result:=_CreateJavaObj(_env, system.TObject.Create, _JNI_system_TObject_Info);
  except
    _HandleJNIException(_env);
    Result:=jobject(0);
  end;
end;

procedure JNI_system_TObject_Destroy(_env: PJNIEnv; _jobj: jobject); {$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  try
    system.TObject(_GetPasObj(_env, _jobj, _JNI_system_TObject_Info, True)).Destroy;
    _env^^.SetLongField(_env, _jobj, _JNI_system_TObject_Info.ObjFieldId, 0);
  except
    _HandleJNIException(_env);
  end;
end;

procedure JNI_system_TObject_Free(_env: PJNIEnv; _jobj: jobject); {$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  try
    system.TObject(_GetPasObj(_env, _jobj, _JNI_system_TObject_Info, True)).Free;
    _env^^.SetLongField(_env, _jobj, _JNI_system_TObject_Info.ObjFieldId, 0);
  except
    _HandleJNIException(_env);
  end;
end;

function JNI_system_TObject_ClassType(_env: PJNIEnv; _jobj: jobject): jobject; {$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  try
    Result:=_CreateJavaObj(_env, -jlong(ptruint(pointer(system.TObject(_GetPasObj(_env, _jobj, _JNI_system_TObject_Info, True)).ClassType))), _JNI_system_TClass_Info);
  except
    _HandleJNIException(_env);
    Result:=jobject(0);
  end;
end;

function JNI_system_TObject_ClassName(_env: PJNIEnv; _jobj: jobject): jstring; {$ifdef mswindows} stdcall {$else} cdecl {$endif};
type _classt = system.TObject;
type _class = class of _classt;
begin
  try
    Result:=_StringToJString(_env, _JNIString(_class(_GetClass(_env, _jobj, _JNI_system_TObject_Info)).ClassName));
  except
    _HandleJNIException(_env);
    Result:=jstring(0);
  end;
end;

function JNI_system_TObject_ClassNameIs(_env: PJNIEnv; _jobj: jobject; p1: jstring): jboolean; {$ifdef mswindows} stdcall {$else} cdecl {$endif};
type _classt = system.TObject;
type _class = class of _classt;
begin
  try
    Result:=(jboolean(_class(_GetClass(_env, _jobj, _JNI_system_TObject_Info)).ClassNameIs(shortstring(_StringFromJString(_env, p1)))) and 1);
  except
    _HandleJNIException(_env);
    Result:=jboolean(0);
  end;
end;

function JNI_system_TObject_ClassParent(_env: PJNIEnv; _jobj: jobject): jobject; {$ifdef mswindows} stdcall {$else} cdecl {$endif};
type _classt = system.TObject;
type _class = class of _classt;
begin
  try
    Result:=_CreateJavaObj(_env, -jlong(ptruint(pointer(_class(_GetClass(_env, _jobj, _JNI_system_TObject_Info)).ClassParent))), _JNI_system_TClass_Info);
  except
    _HandleJNIException(_env);
    Result:=jobject(0);
  end;
end;

function JNI_system_TObject_InstanceSize(_env: PJNIEnv; _jobj: jobject): jint; {$ifdef mswindows} stdcall {$else} cdecl {$endif};
type _classt = system.TObject;
type _class = class of _classt;
begin
  try
    Result:=_class(_GetClass(_env, _jobj, _JNI_system_TObject_Info)).InstanceSize;
  except
    _HandleJNIException(_env);
    Result:=0;
  end;
end;

function JNI_system_TObject_InheritsFrom(_env: PJNIEnv; _jobj: jobject; p1: jobject): jboolean; {$ifdef mswindows} stdcall {$else} cdecl {$endif};
type _classt = system.TObject;
type _class = class of _classt;
begin
  try
    Result:=(jboolean(_class(_GetClass(_env, _jobj, _JNI_system_TObject_Info)).InheritsFrom(system.TClass(_GetClass(_env, p1, _JNI_system_TClass_Info)))) and 1);
  except
    _HandleJNIException(_env);
    Result:=jboolean(0);
  end;
end;

{ TClass }

{ Unit PersonModel }

var _JNI_personmodel_Tperson_Info: _TJavaClassInfo;

{ Tperson }

function JNI_personmodel_Tperson_Create(_env: PJNIEnv; _jobj: jobject; p1: jstring; p2: jstring; p3: jstring): jobject; {$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  try
    Result:=_CreateJavaObj(_env, personmodel.Tperson.Create(ansistring(_StringFromJString(_env, p1)), ansistring(_StringFromJString(_env, p2)), ansistring(_StringFromJString(_env, p3))), _JNI_personmodel_Tperson_Info);
  except
    _HandleJNIException(_env);
    Result:=jobject(0);
  end;
end;

function JNI_personmodel_Tperson_getFirstName(_env: PJNIEnv; _jobj: jobject): jstring; {$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  try
    Result:=_StringToJString(_env, _JNIString(personmodel.Tperson(_GetPasObj(_env, _jobj, _JNI_personmodel_Tperson_Info, True)).getFirstName));
  except
    _HandleJNIException(_env);
    Result:=jstring(0);
  end;
end;

function JNI_personmodel_Tperson_getMiddleName(_env: PJNIEnv; _jobj: jobject): jstring; {$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  try
    Result:=_StringToJString(_env, _JNIString(personmodel.Tperson(_GetPasObj(_env, _jobj, _JNI_personmodel_Tperson_Info, True)).getMiddleName));
  except
    _HandleJNIException(_env);
    Result:=jstring(0);
  end;
end;

function JNI_personmodel_Tperson_getLastName(_env: PJNIEnv; _jobj: jobject): jstring; {$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  try
    Result:=_StringToJString(_env, _JNIString(personmodel.Tperson(_GetPasObj(_env, _jobj, _JNI_personmodel_Tperson_Info, True)).getLastName));
  except
    _HandleJNIException(_env);
    Result:=jstring(0);
  end;
end;

function JNI_personmodel_Tperson_format(_env: PJNIEnv; _jobj: jobject): jstring; {$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  try
    Result:=_StringToJString(_env, _JNIString(personmodel.Tperson(_GetPasObj(_env, _jobj, _JNI_personmodel_Tperson_Info, True)).format));
  except
    _HandleJNIException(_env);
    Result:=jstring(0);
  end;
end;

procedure JNI_personmodel_Tperson_setFirstName(_env: PJNIEnv; _jobj: jobject; p1: jstring); {$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  try
    personmodel.Tperson(_GetPasObj(_env, _jobj, _JNI_personmodel_Tperson_Info, True)).setFirstName(ansistring(_StringFromJString(_env, p1)));
  except
    _HandleJNIException(_env);
  end;
end;

procedure JNI_personmodel_Tperson_setMiddleName(_env: PJNIEnv; _jobj: jobject; p1: jstring); {$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  try
    personmodel.Tperson(_GetPasObj(_env, _jobj, _JNI_personmodel_Tperson_Info, True)).setMiddleName(ansistring(_StringFromJString(_env, p1)));
  except
    _HandleJNIException(_env);
  end;
end;

procedure JNI_personmodel_Tperson_setLastName(_env: PJNIEnv; _jobj: jobject; p1: jstring); {$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  try
    personmodel.Tperson(_GetPasObj(_env, _jobj, _JNI_personmodel_Tperson_Info, True)).setLastName(ansistring(_StringFromJString(_env, p1)));
  except
    _HandleJNIException(_env);
  end;
end;

function _GetRecordSize(env: PJNIEnv; jobj: jobject; index: jint): jint;{$ifdef mswindows} stdcall {$else} cdecl {$endif};
begin
  Result:=0;
end;

function _GetClassRef(env: PJNIEnv; jobj: jobject; index: jint): jlong;{$ifdef mswindows} stdcall {$else} cdecl {$endif};
const cls: array[0..1] of TClass =
  (system.TObject,personmodel.Tperson);
begin
  Result:=-jlong(ptruint(pointer(cls[index])));
end;

function JNI_OnLoad(vm: PJavaVM; reserved: pointer): jint;{$ifdef mswindows} stdcall {$else} cdecl {$endif};
const
  _JNI_personmodel_Tperson_NativeMethods: array[0..7] of JNINativeMethod = (
    (name: 'Create'; signature: '(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lpas/personmodel$Tperson;'; fnPtr: @JNI_personmodel_Tperson_Create),
    (name: 'getFirstName'; signature: '()Ljava/lang/String;'; fnPtr: @JNI_personmodel_Tperson_getFirstName),
    (name: 'getMiddleName'; signature: '()Ljava/lang/String;'; fnPtr: @JNI_personmodel_Tperson_getMiddleName),
    (name: 'getLastName'; signature: '()Ljava/lang/String;'; fnPtr: @JNI_personmodel_Tperson_getLastName),
    (name: 'format'; signature: '()Ljava/lang/String;'; fnPtr: @JNI_personmodel_Tperson_format),
    (name: 'setFirstName'; signature: '(Ljava/lang/String;)V'; fnPtr: @JNI_personmodel_Tperson_setFirstName),
    (name: 'setMiddleName'; signature: '(Ljava/lang/String;)V'; fnPtr: @JNI_personmodel_Tperson_setMiddleName),
    (name: 'setLastName'; signature: '(Ljava/lang/String;)V'; fnPtr: @JNI_personmodel_Tperson_setLastName)
  );
  _JNI_personmodeljni_MethodPtr_NativeMethods: array[0..1] of JNINativeMethod = (
    (name: '__Init'; signature: '(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;Z)V'; fnPtr: @_TMethodPtrInfo_Init),
    (name: '__Destroy'; signature: '()V'; fnPtr: @_TMethodPtrInfo_Release)
  );
  _JNI_system_NativeMethods: array[0..3] of JNINativeMethod = (
    (name: 'AllocMemory'; signature: '(I)J'; fnPtr: @_AllocMemory),
    (name: 'GetClassRef'; signature: '(I)J'; fnPtr: @_GetClassRef),
    (name: 'GetRecordSize'; signature: '(I)I'; fnPtr: @_GetRecordSize),
    (name: 'InterfaceCast'; signature: '(JLjava/lang/String;)J'; fnPtr: @_IntfCast)
  );
  _JNI_system_TObject_NativeMethods: array[0..8] of JNINativeMethod = (
    (name: 'Create'; signature: '()Lpas/system$TObject;'; fnPtr: @JNI_system_TObject_Create),
    (name: 'Destroy'; signature: '()V'; fnPtr: @JNI_system_TObject_Destroy),
    (name: 'Free'; signature: '()V'; fnPtr: @JNI_system_TObject_Free),
    (name: 'ClassType'; signature: '()Lpas/system$TClass;'; fnPtr: @JNI_system_TObject_ClassType),
    (name: 'ClassName'; signature: '()Ljava/lang/String;'; fnPtr: @JNI_system_TObject_ClassName),
    (name: 'ClassNameIs'; signature: '(Ljava/lang/String;)Z'; fnPtr: @JNI_system_TObject_ClassNameIs),
    (name: 'ClassParent'; signature: '()Lpas/system$TClass;'; fnPtr: @JNI_system_TObject_ClassParent),
    (name: 'InstanceSize'; signature: '()I'; fnPtr: @JNI_system_TObject_InstanceSize),
    (name: 'InheritsFrom'; signature: '(Lpas/system$TClass;)Z'; fnPtr: @JNI_system_TObject_InheritsFrom)
  );

var
  env: PJNIEnv;

  function _Reg(ClassName: PAnsiChar; Methods: PJNINativeMethod; Count: integer; ci: _PJavaClassInfo; const FieldName: ansistring = '_pasobj'; const FieldSig: ansistring = 'J'): boolean;
  var
    c: jclass;
  begin
    Result:=False;
    c:=env^^.FindClass(env, ClassName);
    if c = nil then exit;
    Result:=(Count = 0) or (env^^.RegisterNatives(env, c, Methods, Count) = 0);
    if Result and (ci <> nil) then begin
      ci^.ClassRef:=env^^.NewGlobalRef(env, c);
      Result:=ci^.ClassRef <> nil;
      if Result and (env^^.ExceptionCheck(env) = 0) then begin
        ci^.ConstrId:=env^^.GetMethodID(env, ci^.ClassRef, '<init>', '(JZ)V');
        env^^.ExceptionClear(env);
      end;
      if Result and (FieldName <> '') then begin
        ci^.ObjFieldId:=env^^.GetFieldID(env, ci^.ClassRef, PAnsiChar(FieldName), PAnsiChar(FieldSig));
        Result:=ci^.ObjFieldId <> nil;
      end;
    end;
  end;

begin
  Result:=JNI_ERR;
  if vm^^.GetEnv(vm, @env, JNI_VERSION_1_6) <> JNI_OK then exit;
  CurJavaVM:=vm;
  if not _Reg('java/lang/String', nil, 0, @_Java_String_Info, '', '') then exit;
  if not _Reg('pas/personmodel$Tperson', @_JNI_personmodel_Tperson_NativeMethods, 8, @_JNI_personmodel_Tperson_Info) then exit;
  if not _Reg('pas/system$MethodPtr', @_JNI_personmodeljni_MethodPtr_NativeMethods, 2, @_JNI_personmodeljni__TMethodPtrInfo_Info) then exit;
  if not _Reg('pas/system', @_JNI_system_NativeMethods, 4, nil) then exit;
  if not _Reg('pas/system$TClass', nil, 0, @_JNI_system_TClass_Info) then exit;
  if not _Reg('pas/system$TObject', @_JNI_system_TObject_NativeMethods, 9, @_JNI_system_TObject_Info) then exit;
  Result:=JNI_VERSION_1_6;
end;

exports JNI_OnLoad;

procedure ___doexit;
begin
  _MethodPointersCS.Free;
end;

begin
  ExitProc:=@___doexit;
  IsMultiThread:=True;
  _MethodPointersCS:=TCriticalSection.Create;
end.
